"""
RAW SOCKETS:
    Extraindo Dados Binários para Variáveis
    A ordem de leitura dos bytes ba rede é big-endian⁴
    Sniffer de Pacotes Recebidos
"""

import socket

def strEthernet(ethernet: bytes):
    """
    Pega o MAC Address em bytes e faz a formatação de bytes para string
    
    :param ethernet: bytes

    :return strEthernet:
    """
    ethernet = ethernet.hex().upper()
    strEthernet = ''
    for i in range(0, 10, 2):
        strEthernet += f'{ethernet[i:(i+2)]}:'
    strEthernet += ethernet[10:]
    return strEthernet

def parseEthernet(headers: bytes):
    """
    Pega o cabeçalho do ethernet - Traz os primeiros 14 bytes 
    0               5 6             11 12           14
    |    EthDHost    |    EthSHost    |    EthType    |

    :param headers: bytes

    :return ethType == b'\x08\x00':
    """
    ethDHost = headers[:6]
    ethSHost = headers[6:12]
    ethType = headers[12:]
    print('###[ Ethernet ] ###')
    print(f'    Fonte:\t {strEthernet(ethSHost)}')
    print(f'    Destino:\t {strEthernet(ethDHost)}')
    return ethType == b'\x08\x00'

def parseIP(headers: bytes):
    """
    Extrai informações do cabeçalho IP

    :param headers: bytes

    :return 'TCP' if type == b'\x06': 
    :return 'UDP' if type == b'\x11':
    :return '':
    """
    type = headers[9:10]
    ipS = headers[12:16]
    ipD = headers[16:20]
    print('###[ IP  ]###')
    #inet_ntoa: ip(bytes) -> str
    print(f'    Fonte:\t {socket.inet_ntoa(ipS)}')      
    print(f'    Destino:\t {socket.inet_ntoa(ipD)}')
    if type == b'\x06':
        return 'TCP'
    if type == b'\x11':
        return 'UDP'
    return ''

def parseTCP(headers: bytes):
    """
    Extrai a porta fonte e porta destino do TCP

    :param headers: bytes

    :return SPort == 80:
    """
    SPort = int.from_bytes(headers[:2], byteorder='big')
    DPort = int.from_bytes(headers[2:4], byteorder='big')
    print('###[ TCP ]###')
    print(f'    Porta Fonte:\t {SPort}')
    print(f'    Porta Destino:\t {DPort}')
    #port 80 = http
    return SPort == 80

def parseUDP(headers: bytes):
    """
    Extrai a porta fonte e a porta destino do UDP

    :param headers: bytes

    """
    SPort = headers[:2]
    DPort = headers[2:4]
    print('###[ UDP ]###')
    print(f'    Porta Fonte:\t {int.from_bytes(SPort, byteorder="big")}')
    print(f'    Porta Destino:\t {int.from_bytes(DPort, byteorder="big")}')


#Construção do Socket
rawSocket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x800))

while True:
    rawPkt = rawSocket.recvfrom(2048)[0]    #captura o pacote
    print('\n\nPacote recebido:\n')
    if parseEthernet(rawPkt[:14]):          #pega do 0 - 14 (bytes)
        PktType = parseIP(rawPkt[14:34])    #se tiver pacote ip => 14 - 34 (bytes)
        if PktType:
            if PktType == 'UDP':
                parseUDP(rawPkt[34:42])
            if PktType == 'TCP':
                if parseTCP(rawPkt[34:54]): #se tiver vindo da porta 80, printa os dados
                    print(rawPkt[54:])
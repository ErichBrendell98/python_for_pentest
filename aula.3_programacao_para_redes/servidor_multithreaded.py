"""
Criação de um Servidor Multithreaded

Threads: Executam no mesmo processo, ou seja, compartilham o mesmo espaço de memória

Ótimo para operações de I/O;
Mais econômico quanro aos recursos computacionais;
Precisa esperar o término da execução de todas as threads para parar a aplicação
"""

import socket, threading, sys

def clientHandler(clientSocket, clientAddr):
    isConnected = True
    while isConnected:
        data = clientSocket.recv(1024)
        if data:
            clientSocket.send(data)
        else:
            clientIP, clientPort = clientAddr
            print(f'Client {clientIP}:{clientPort} left')
            clientSocket.close()
            isConnected = False

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('', int(sys.argv[1])))
server.listen(10)
while True:
    clientSocket, addr = server.accept()    #enquanto a thread vai executando o clientHandler "por baixo dos planos", o accept fica aguardando novas conexões
    clientIP, clientPort = addr
    print(f'New client connected from {clientIP}:{clientPort}')
    threading.Thread(target=clientHandler, args=(clientSocket,addr)).start()     #target:callback para clientHandler